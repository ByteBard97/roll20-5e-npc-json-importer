### Future Enhancement: Automated Spellbook Population

This document outlines the strategy and provides placeholder code for enhancing the importer to automatically populate an NPC's spellbook by fetching data from an external API.

#### Core Concepts

This implementation will be built on three key concepts we uncovered:

1.  **Asynchronous API Calls with `fetch()`:** The Roll20 API sandbox allows us to make external web requests using `fetch()`. This is an *asynchronous* operation. Our script will send a request and use `.then()` blocks to handle the response when it arrives, without halting the rest of the game. This is the modern alternative to including a massive, built-in Look-Up Table (LUT) like `SRD.js`.

2.  **The Sheet's Two-Part System for Attack Spells:** For a spell that includes an attack roll (like *Fire Bolt*), the "D&D 5e by Roll20" character sheet creates **two** separate, linked entries:
    * **A Spellbook Entry (`repeating_spell-<level>_...`):** This lives on the "Spells" tab and contains the full description, components, duration, etc.
    * **An Attack Entry (`repeating_attack_...`):** This lives on the main "NPC" tab in the "Attacks & Spellcasting" box. It's a clickable shortcut for rolling the attack and damage.
    Our script will need to create both of these entries and link them together.

3.  **The `rollbase` Challenge:** The `rollbase` attribute within an Attack entry is a massive, complex macro string that is normally auto-generated by the character sheet's internal scripts ("sheet workers") when a spell is dragged from the Compendium. Replicating this *perfectly* is extremely difficult. Our initial implementation will use a simplified, but functional, `rollbase`.

#### Proposed Implementation & Functions

Below are the functions we can add to the importer script.

##### 1. The Main Orchestrator (`importSpellsForCharacter`)

This function will be the main entry point for the new feature. It will read a simple list of spell names from your importer's JSON data and kick off the process for each one.

```javascript
/**
 * Processes the 'spells' array from the imported JSON data, fetching and creating
 * each spell on the character sheet.
 * @param {string} charId - The Roll20 character ID for the NPC.
 * @param {object} npcJsonData - The full parsed JSON object for the NPC.
 */
function importSpellsForCharacter(charId, npcJsonData) {
    if (!npcJsonData.spells || typeof npcJsonData.spells !== 'object') {
        return; // No spells to import
    }

    log(`[Import Spells] Starting spell import for character ID: ${charId}`);

    // Loop through all spell levels defined in the JSON (e.g., "cantrips", "1", "2")
    for (const levelKey in npcJsonData.spells) {
        if (Array.isArray(npcJsonData.spells[levelKey])) {
            npcJsonData.spells[levelKey].forEach(spellName => {
                // For each spell name, call the fetch function.
                // The fetch function will handle the rest of the process asynchronously.
                fetchSpellDataAndCreateEntries(charId, spellName);
            });
        }
    }
}
```

##### 2. The API Caller (`fetchSpellDataAndCreateEntries`)

This function handles the `fetch` call for a single spell. Upon a successful response, it passes the data to the function that writes to the character sheet.

```javascript
/**
 * Fetches data for a single spell from the dnd5eapi.co API.
 * On success, it calls the function to create the sheet entries.
 * @param {string} charId - The Roll20 character ID.
 * @param {string} spellName - The name of the spell to fetch (e.g., "Fire Bolt").
 */
function fetchSpellDataAndCreateEntries(charId, spellName) {
    const formattedName = spellName.toLowerCase().replace(/\s+/g, '-');
    const apiURL = `https://www.dnd5eapi.co/api/spells/${formattedName}`;

    fetch(apiURL)
        .then(response => {
            if (!response.ok) { throw new Error(`API returned an error: ${response.statusText}`); }
            return response.json();
        })
        .then(spellApiData => {
            // Success! We have the spell data from the API.
            // Now, call the function that creates the Roll20 objects.
            log(`[Import Spells] Fetched data for "${spellName}", now creating sheet entries.`);
            createSpellEntries(charId, spellApiData);
        })
        .catch(error => {
            log(`!!! [Import Spells] ERROR fetching data for "${spellName}": ${error}`);
            // Optionally, whisper this error to the GM.
            // sendChat('NPC Importer', `/w gm ⚠️ Could not fetch data for spell: ${spellName}.`);
        });
}
```

##### 3. The Sheet Writer (`createSpellEntries`)

This is the most complex function. It takes the data from the API and creates all the necessary `attribute` objects on the character sheet. This function demonstrates the "two-part system."

```javascript
/**
 * Creates the necessary attributes for a single spell on the character sheet.
 * This includes the spellbook entry and, if applicable, a linked attack entry.
 * @param {string} charId - The Roll20 character ID.
 * @param {object} spellApiData - The full spell data object from the dnd5eapi.co.
 */
function createSpellEntries(charId, spellApiData) {
    const utils = ImportJSON_Utils; // Accessing the utils from your script
    const spellbookRowId = utils.genRowID(); // Unique ID for the spellbook entry
    const spellLevelKey = spellApiData.level === 0 ? "cantrip" : String(spellApiData.level);

    // --- Part 1: Create the Spellbook Entry (`repeating_spell-<level>`) ---
    const spellbookAttributes = {
        'spellname': spellApiData.name,
        'spelllevel': spellApiData.level,
        'school': spellApiData.school.name,
        'ritual': (spellApiData.ritual) ? '{{ritual=1}}' : '0',
        'spellcastingtime': spellApiData.casting_time,
        'spellrange': spellApiData.range,
        'spellcomp_v': (spellApiData.components || []).includes('V') ? '1' : '0',
        'spellcomp_s': (spellApiData.components || []).includes('S') ? '1' : '0',
        'spellcomp_m': (spellApiData.components || []).includes('M') ? '1' : '0',
        'spellcomp_materials': spellApiData.material || "",
        'spelldescription': (spellApiData.desc || []).join('\n\n'),
        'spellathigherlevels': (spellApiData.higher_level || []).join('\n\n'),
        'spellprepared': '1' // Default to "prepared" for NPCs
    };

    for (const [field, value] of Object.entries(spellbookAttributes)) {
        const attrName = `repeating_spell-${spellLevelKey}_${spellbookRowId}_${field}`;
        utils.global_createObj("attribute", { name: attrName, current: value, characterid: charId });
    }
    log(`[Import Spells] Created spellbook entry for ${spellApiData.name}.`);

    // --- Part 2: If it's an attack spell, create the linked Attack Entry ---
    if (spellApiData.attack_type) {
        const attackRowId = utils.genRowID(); // A *different* ID for the attack entry

        // This is a simplified `rollbase` macro. Perfectly replicating the sheet's
        // auto-generated macro is a significant challenge. This version is functional.
        // TODO: Enhance this rollbase to be more robust in the future.
        const simplifiedRollbase = "@{wtype}&{template:npcatk} {{attack=1}} {{rname=@{atkname}}} {{r1=[[@{d20}+@{atkbonus}]]}} {{damage=1}} {{dmg1flag=1}} {{dmg1=[[@{dmgbase}]]}} {{dmg1type=@{dmgtype}}}";

        const attackAttributes = {
            'atkname': spellApiData.name,
            'atkattr_base': 'spell', // Marks it as a spell attack
            'atkbonus': `@{spell_attack_bonus}`, // Let the sheet calculate the bonus
            'dmgbase': spellApiData.damage?.damage_dice || "",
            'dmgtype': spellApiData.damage?.damage_type?.name || "",
            'atkrange': spellApiData.range,
            'spellid': spellbookRowId, // This is the crucial link back to the spellbook entry
            'rollbase': simplifiedRollbase
        };

        for (const [field, value] of Object.entries(attackAttributes)) {
            const attrName = `repeating_attack_${attackRowId}_${field}`;
            utils.global_createObj("attribute", { name: attrName, current: value, characterid: charId });
        }
        log(`[Import Spells] Created linked attack entry for ${spellApiData.name}.`);
    }
}
```